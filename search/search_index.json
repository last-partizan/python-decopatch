{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"decopatch \u00b6 python decorators made easy. Because of a tiny oddity in the python language, writing decorators without help can be a pain because you have to handle the no-parenthesis usage explicitly . decopatch provides a simple way to solve this issue so that writing decorators is simple and straightforward. Installing \u00b6 > pip install decopatch Usage \u00b6 1- As usual, a.k.a nested mode \u00b6 Let's create a add_tag decorator, that will simply add a new attribute on the decorated function: from decopatch import function_decorator @function_decorator def add_tag ( tag = 'hi!' ): \"\"\" Example decorator to add a 'tag' attribute to a function. :param tag: the 'tag' value to set on the decorated function (default 'hi!). \"\"\" def _apply_decorator ( f ): \"\"\" This is the method that will be called when `@add_tag` is used on a function `f`. It should return a replacement for `f`. \"\"\" setattr ( f , 'tag' , tag ) return f return _apply_decorator Apart from the new @function_decorator , it should look very familiar to those of you who tried to write decorators using the native python mechanisms. Except that it works out of the box with and without parenthesis, with and without arguments: @add_tag # no parenthesis def foo (): pass assert foo . tag == 'hi!' @add_tag () # empty parenthesis def foo (): pass assert foo . tag == 'hi!' @add_tag ( 'hello' ) # with args def foo (): pass assert foo . tag == 'hello' add_tag ()( foo ) # manual decoration assert foo . tag == 'hi!' Besides, its signature and docstring are preserved: print ( \" %s%s \" % ( add_tag . __name__ , signature ( add_tag ))) print ( help ( add_tag )) yields add_tag ( tag = 'hi!' ) Help on function add_tag in module decopatch.tests.test_doc: add_tag ( tag = 'hi!' ) Example decorator to add a 'tag' attribute to a function . :param tag: the 'tag' value to set on the decorated function ( default ' hi! ) . Finally note that _apply_decorator can return a wrapper, but is not forced to: you are free to return f , a wrapper of f , or a complete replacement for f , not even a function! This is the default python language capability, but we tend to forget it when we use wrapt or decorator because they are designed for wrappers. 2- More compact: flat mode \u00b6 To ease code readability, decopatch also supports a flat mode: from decopatch import function_decorator , DECORATED @function_decorator def add_tag ( tag = 'hi!' , f = DECORATED ): \"\"\" Example decorator to add a 'tag' attribute to a function. :param tag: the 'tag' value to set on the decorated function (default 'hi!). \"\"\" setattr ( f , 'tag' , tag ) return f As you can see, in that mode you can use one less level of nesting. You indicate which argument is the decorated object by using the DECORATED default value. But the cool thing is that using this development style does not change the signature that gets exposed to your users: they do not see the DECORATED argument, you can check it with help(add_tag) ! Of course you should not mention it in the docstring. 3- Creating function wrappers \u00b6 A very popular use case for decorators is to create signature-preserving function wrappers. The great decorator library in particular, provides tools to solve this problem \"all at once\" (decorator + signature-preserving wrapper). With decopatch and its optional companion makefun , each problem is now solved in a dedicated library, because the author believes that these are two completely independent problems. decopatch (this library) focuses on helping you create decorators that nicely handle the without-parenthesis case. You can decorate functions and classes, and your decorator is free to return anything (the same object that was decorated, a wrapper, or another object). makefun can be used to generate functions with any signature dynamically ; in particular its @wraps decorator makes it very easy to create signature-preserving wrappers. It relies on the same tricks than decorator to perform the function generation, but also supports more complex use cases such as signature modification. It can be used anywhere of course, it is not specific to decorators. Both work well together of course: from decopatch import function_decorator , DECORATED from makefun import wraps @function_decorator def say_hello ( person = \"world\" , f = DECORATED ): \"\"\" This decorator modifies the decorated function so as to print a greetings message before each execution. :param person: the person name in the print message. Default = \"world\" \"\"\" # (1) create a wrapper of f that will do the print before call @wraps ( f ) # rely on `makefun` to preserve signature of `f` def new_f ( * args , ** kwargs ): print ( \"hello, %s !\" % person ) # say hello return f ( * args , ** kwargs ) # execute f # (2) return it as a replacement for `f` return new_f Once again, you can check that all call modes are properly implemented: @say_hello # no parenthesis def foo (): print ( \"<executing foo>\" ) foo () @say_hello () # empty parenthesis def bar (): print ( \"<executing bar>\" ) bar () @say_hello ( \"you\" ) # arg def custom (): print ( \"<executing custom>\" ) custom () # manual decoration def custom2 (): print ( \"<executing custom2>\" ) custom2 = say_hello ()( custom2 ) custom2 () yields hello, world ! <executing foo> hello, world ! <executing bar> hello, you ! <executing custom> hello, world ! <executing custom2> As stated previously, you can use any other means to generate your function wrapper at step (1) of this example, such as functools.wraps , etc. But beware that not all of them are signature-preserving! ...even simpler ? \u00b6 If you really want to avoid nesting in the above example (and take the risk of making your code less readable), decopatch supports a double-flat mode: from decopatch import function_decorator , WRAPPED , F_ARGS , F_KWARGS @function_decorator def say_hello ( person = \"world\" , f = WRAPPED , f_args = F_ARGS , f_kwargs = F_KWARGS ): \"\"\" This decorator modifies the decorated function so as to print a greetings message before execution. :param person: the person name in the print message. Default = \"world\" \"\"\" print ( \"hello, %s !\" % person ) # say hello return f ( * f_args , ** f_kwargs ) # execute f This syntax is completely equivalent to the one shown previously. You can check it: @say_hello # no parenthesis def add_ints ( a , b ): return a + b assert add_ints ( 1 , 3 ) == 4 yields hello, world ! As you can see above, the principles of this syntax are simple: all arguments are decorator arguments, except for the ones with default values WRAPPED (the decorated item), F_ARGS and F_KWARGS (the *args and **kwargs of each function call). 4- Decorating classes \u00b6 You can similarly use @class_decorator to create a decorator that works for classes. Both @function_decorator and @class_decorator are actually user-friendly presets for the more generic @decorator function. So if you wish to write a decorator that can be used both for functions and classes, use @decorator : from decopatch import decorator @decorator def add_tag ( tag = 'hi!' ): \"\"\" Example decorator to add a 'tag' attribute to a function or class. :param tag: the 'tag' value to set on the decorated item (default 'hi!). \"\"\" def _apply_decorator ( o ): \"\"\" This is the method that will be called when your decorator is used on a class or function `o`. It should return the replacement for this object. \"\"\" setattr ( o , 'tag' , tag ) return o return _apply_decorator How does it work ? \u00b6 There is no magic here. Without language modification (see proposal ) or additional knowledge or source code introspection, python is just not capable of detecting that @say_hello(foo) is different from @say_hello applied to function foo . However in most standard cases there are well-known \"tricks\" to perform a disambiguation that covers most standard cases. decopatch is basically a collection of such tricks. Some of them are static, based on your decorator's signature, and some others are dynamic, based on the received arguments. See disambiguation details for the complete list and for advanced usage. See Also \u00b6 PEP318 decorators for functions and methods PEP3129 decorators for classes decorator , the reference library for creating decorators in python. I used it a lot before writing makefun and decopatch , big thanks to micheles ! tutorial 1 tutorial 2 tutorial 3 tutorial 4 decorator recipes Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-decopatch","title":"Home"},{"location":"#decopatch","text":"python decorators made easy. Because of a tiny oddity in the python language, writing decorators without help can be a pain because you have to handle the no-parenthesis usage explicitly . decopatch provides a simple way to solve this issue so that writing decorators is simple and straightforward.","title":"decopatch"},{"location":"#installing","text":"> pip install decopatch","title":"Installing"},{"location":"#usage","text":"","title":"Usage"},{"location":"#1-as-usual-aka-nested-mode","text":"Let's create a add_tag decorator, that will simply add a new attribute on the decorated function: from decopatch import function_decorator @function_decorator def add_tag ( tag = 'hi!' ): \"\"\" Example decorator to add a 'tag' attribute to a function. :param tag: the 'tag' value to set on the decorated function (default 'hi!). \"\"\" def _apply_decorator ( f ): \"\"\" This is the method that will be called when `@add_tag` is used on a function `f`. It should return a replacement for `f`. \"\"\" setattr ( f , 'tag' , tag ) return f return _apply_decorator Apart from the new @function_decorator , it should look very familiar to those of you who tried to write decorators using the native python mechanisms. Except that it works out of the box with and without parenthesis, with and without arguments: @add_tag # no parenthesis def foo (): pass assert foo . tag == 'hi!' @add_tag () # empty parenthesis def foo (): pass assert foo . tag == 'hi!' @add_tag ( 'hello' ) # with args def foo (): pass assert foo . tag == 'hello' add_tag ()( foo ) # manual decoration assert foo . tag == 'hi!' Besides, its signature and docstring are preserved: print ( \" %s%s \" % ( add_tag . __name__ , signature ( add_tag ))) print ( help ( add_tag )) yields add_tag ( tag = 'hi!' ) Help on function add_tag in module decopatch.tests.test_doc: add_tag ( tag = 'hi!' ) Example decorator to add a 'tag' attribute to a function . :param tag: the 'tag' value to set on the decorated function ( default ' hi! ) . Finally note that _apply_decorator can return a wrapper, but is not forced to: you are free to return f , a wrapper of f , or a complete replacement for f , not even a function! This is the default python language capability, but we tend to forget it when we use wrapt or decorator because they are designed for wrappers.","title":"1- As usual, a.k.a nested mode"},{"location":"#2-more-compact-flat-mode","text":"To ease code readability, decopatch also supports a flat mode: from decopatch import function_decorator , DECORATED @function_decorator def add_tag ( tag = 'hi!' , f = DECORATED ): \"\"\" Example decorator to add a 'tag' attribute to a function. :param tag: the 'tag' value to set on the decorated function (default 'hi!). \"\"\" setattr ( f , 'tag' , tag ) return f As you can see, in that mode you can use one less level of nesting. You indicate which argument is the decorated object by using the DECORATED default value. But the cool thing is that using this development style does not change the signature that gets exposed to your users: they do not see the DECORATED argument, you can check it with help(add_tag) ! Of course you should not mention it in the docstring.","title":"2- More compact: flat mode"},{"location":"#3-creating-function-wrappers","text":"A very popular use case for decorators is to create signature-preserving function wrappers. The great decorator library in particular, provides tools to solve this problem \"all at once\" (decorator + signature-preserving wrapper). With decopatch and its optional companion makefun , each problem is now solved in a dedicated library, because the author believes that these are two completely independent problems. decopatch (this library) focuses on helping you create decorators that nicely handle the without-parenthesis case. You can decorate functions and classes, and your decorator is free to return anything (the same object that was decorated, a wrapper, or another object). makefun can be used to generate functions with any signature dynamically ; in particular its @wraps decorator makes it very easy to create signature-preserving wrappers. It relies on the same tricks than decorator to perform the function generation, but also supports more complex use cases such as signature modification. It can be used anywhere of course, it is not specific to decorators. Both work well together of course: from decopatch import function_decorator , DECORATED from makefun import wraps @function_decorator def say_hello ( person = \"world\" , f = DECORATED ): \"\"\" This decorator modifies the decorated function so as to print a greetings message before each execution. :param person: the person name in the print message. Default = \"world\" \"\"\" # (1) create a wrapper of f that will do the print before call @wraps ( f ) # rely on `makefun` to preserve signature of `f` def new_f ( * args , ** kwargs ): print ( \"hello, %s !\" % person ) # say hello return f ( * args , ** kwargs ) # execute f # (2) return it as a replacement for `f` return new_f Once again, you can check that all call modes are properly implemented: @say_hello # no parenthesis def foo (): print ( \"<executing foo>\" ) foo () @say_hello () # empty parenthesis def bar (): print ( \"<executing bar>\" ) bar () @say_hello ( \"you\" ) # arg def custom (): print ( \"<executing custom>\" ) custom () # manual decoration def custom2 (): print ( \"<executing custom2>\" ) custom2 = say_hello ()( custom2 ) custom2 () yields hello, world ! <executing foo> hello, world ! <executing bar> hello, you ! <executing custom> hello, world ! <executing custom2> As stated previously, you can use any other means to generate your function wrapper at step (1) of this example, such as functools.wraps , etc. But beware that not all of them are signature-preserving!","title":"3- Creating function wrappers"},{"location":"#even-simpler","text":"If you really want to avoid nesting in the above example (and take the risk of making your code less readable), decopatch supports a double-flat mode: from decopatch import function_decorator , WRAPPED , F_ARGS , F_KWARGS @function_decorator def say_hello ( person = \"world\" , f = WRAPPED , f_args = F_ARGS , f_kwargs = F_KWARGS ): \"\"\" This decorator modifies the decorated function so as to print a greetings message before execution. :param person: the person name in the print message. Default = \"world\" \"\"\" print ( \"hello, %s !\" % person ) # say hello return f ( * f_args , ** f_kwargs ) # execute f This syntax is completely equivalent to the one shown previously. You can check it: @say_hello # no parenthesis def add_ints ( a , b ): return a + b assert add_ints ( 1 , 3 ) == 4 yields hello, world ! As you can see above, the principles of this syntax are simple: all arguments are decorator arguments, except for the ones with default values WRAPPED (the decorated item), F_ARGS and F_KWARGS (the *args and **kwargs of each function call).","title":"...even simpler ?"},{"location":"#4-decorating-classes","text":"You can similarly use @class_decorator to create a decorator that works for classes. Both @function_decorator and @class_decorator are actually user-friendly presets for the more generic @decorator function. So if you wish to write a decorator that can be used both for functions and classes, use @decorator : from decopatch import decorator @decorator def add_tag ( tag = 'hi!' ): \"\"\" Example decorator to add a 'tag' attribute to a function or class. :param tag: the 'tag' value to set on the decorated item (default 'hi!). \"\"\" def _apply_decorator ( o ): \"\"\" This is the method that will be called when your decorator is used on a class or function `o`. It should return the replacement for this object. \"\"\" setattr ( o , 'tag' , tag ) return o return _apply_decorator","title":"4- Decorating classes"},{"location":"#how-does-it-work","text":"There is no magic here. Without language modification (see proposal ) or additional knowledge or source code introspection, python is just not capable of detecting that @say_hello(foo) is different from @say_hello applied to function foo . However in most standard cases there are well-known \"tricks\" to perform a disambiguation that covers most standard cases. decopatch is basically a collection of such tricks. Some of them are static, based on your decorator's signature, and some others are dynamic, based on the received arguments. See disambiguation details for the complete list and for advanced usage.","title":"How does it work ?"},{"location":"#see-also","text":"PEP318 decorators for functions and methods PEP3129 decorators for classes decorator , the reference library for creating decorators in python. I used it a lot before writing makefun and decopatch , big thanks to micheles ! tutorial 1 tutorial 2 tutorial 3 tutorial 4 decorator recipes","title":"See Also"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-decopatch","title":"Want to contribute ?"},{"location":"changelog/","text":"Changelog \u00b6 1.4.10 - Type hints step 1 \u00b6 @function_decorator now has proper type hints. This is a first step towards fixing #22 . PR #23 by last-partizan . 1.4.9 - New layout and CI + Compatibility fixes. \u00b6 Enabling the \"stack introspection\" beta feature with enable_stack_introspection=True now raises an explicit NotImplementedError on python 3.8+. Fixed #26 . Migrated to the new project layout with nox, github-actions and separation of src and tests . Fixed test suite with pytest-cases>=3 . Fixed #24 and #20 . 1.4.8 - better packaging \u00b6 packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file, as well as set the zip_safe flag to False. Removed tests folder from package. Fixes #19 1.4.7 - pyproject.toml \u00b6 raddessi added a pyproject.toml - thanks! Fixed pytest-cases#65 . 1.4.6 - Bug fix \u00b6 Fixed decorated object injection issue when var-positional arguments are located before it in the signature. Fixed #14 . Added __version__ attribute to comply with PEP396, following this guide . Fixes #15 . PyPI supports markdown via long_description_content_type : pypandoc is not required anymore. Thanks minrk ! 1.4.5 - Performance improvement \u00b6 Huge performance improvement for the enable_stack_introspection=True mode. It also now supports classes correctly. 1.4.4 - Reverted varpositional bugfixes now that they are handled in makefun \u00b6 1.4.3 - Bugfix in nested mode under python 2 \u00b6 In python 2, when nested mode was used in a context where the signature contains a var-positional argument, a TypeError was raised ; this is now fixed. Fixes #13 . 1.4.2 - Bugfix in flat mode under python 2 \u00b6 In python 2, when flat mode was used in a context where the signature contains a var-positional argument, the arguments were not correctly injected. Fixes #12 . 1.4.1 - Minor default symbols improvement \u00b6 Removed the clunky Enum for symbols. Back to a normal class, with a custom __repr__ . 1.4.0 - Minor dependency version update \u00b6 Now relying on makefun>=1.5.0 where arg names changed a bit. 1.3.0 - Predefined disambiguators and init file fix \u00b6 We now provide predefined disambiguators with_parenthesis and no_parenthesis . Fixes #8 . Fixed KeyError when the signature contains **kwargs . Fixes #9 . Fixed issue when the signature only contains **kwargs . Fixes #10 Fixed static checker problem in PyCharm with the symbols (it came back when we moved to an Enum) Improved exception re-raising in flat mode. Minor: fixed init file. 1.2.1 - Flat and double flat symbols: additional protection and bugfix \u00b6 Default-value symbols DECORATED , WRAPPED , F_ARGS and F_KWARGS now have a nicer representation. Fixes #7 . When a symbol is used in a signature where it can not be safely injected as keyword argument, an InvalidSignatureError is now raised. Fixes #6 . 1.2.0 - Dependency update for important fix \u00b6 makefun>=1.4.0 is now required, as it fixes a major issue: #5 1.1.1 - Symbols are not classes anymore \u00b6 Default-value symbols DECORATED , WRAPPED , F_ARGS and F_KWARGS are now objects and not classes any more. This prevents IDE to flag the corresponding argument as being misused (not iterable...). Fixes #4 . 1.1.0 - Dependency update \u00b6 The double-flat mode now relies on @makefun.wraps , from makefun>=1.3.0 . Fixes #3 . Updated documentation accordingly. 1.0.0 - Refactoring + New \"double-flat\" mode + API changes + documentation \u00b6 API changes: Added support for a new \"double-flat\" mode so that users can create decorators creating signature-preserving function wrappers with zero level of nesting. Fixes #2 . Generated var-positional name for kw-only methods is now '*_' can_first_arg_be_ambiguous parameter removed completely, it was too complex to use. callable_or_cls_firstarg_disambiguator renamed custom_disambiguator to be more intuitive wraps argument renamed flat_mode_decorated_name . It was too similar to the wording used in functools, and specific to the flat mode only. Fixes #1 . Improved behaviour Now the flat mode behaves exactly like nested mode concerning signature-related TypeError . This is because when you use the flat mode we now generate a nested mode function with a true signature. Now the exposed decorator uses the __wrapped__ trick to expose Major refactoring for code readability: Submodules are now consistent and readable. In particular utils_disambiguation now provides a clear disambiguate_call method, and util_modes provides a clear make_decorator_spec to handle all the per-mode specificity and always come back to a nested case before going further. removed a case in the main module (var-positional) as it was completely covered by the general case. Information is now passed as objects through the various functions, using two main classes SignatureInfo (for static information) and DecoratorUsageInfo (for dynamic/usage information). The information is computed in a lazy way for each to avoid unnecessary signature binding for example. Major documentation update. 0.5.0 - First version \u00b6 Fully functional with 100+ tests.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#1410-type-hints-step-1","text":"@function_decorator now has proper type hints. This is a first step towards fixing #22 . PR #23 by last-partizan .","title":"1.4.10 - Type hints step 1"},{"location":"changelog/#149-new-layout-and-ci-compatibility-fixes","text":"Enabling the \"stack introspection\" beta feature with enable_stack_introspection=True now raises an explicit NotImplementedError on python 3.8+. Fixed #26 . Migrated to the new project layout with nox, github-actions and separation of src and tests . Fixed test suite with pytest-cases>=3 . Fixed #24 and #20 .","title":"1.4.9 - New layout and CI + Compatibility fixes."},{"location":"changelog/#148-better-packaging","text":"packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the setup.py . In particular removed dependency to six for setup and added py.typed file, as well as set the zip_safe flag to False. Removed tests folder from package. Fixes #19","title":"1.4.8 - better packaging"},{"location":"changelog/#147-pyprojecttoml","text":"raddessi added a pyproject.toml - thanks! Fixed pytest-cases#65 .","title":"1.4.7 - pyproject.toml"},{"location":"changelog/#146-bug-fix","text":"Fixed decorated object injection issue when var-positional arguments are located before it in the signature. Fixed #14 . Added __version__ attribute to comply with PEP396, following this guide . Fixes #15 . PyPI supports markdown via long_description_content_type : pypandoc is not required anymore. Thanks minrk !","title":"1.4.6 - Bug fix"},{"location":"changelog/#145-performance-improvement","text":"Huge performance improvement for the enable_stack_introspection=True mode. It also now supports classes correctly.","title":"1.4.5 - Performance improvement"},{"location":"changelog/#144-reverted-varpositional-bugfixes-now-that-they-are-handled-in-makefun","text":"","title":"1.4.4 - Reverted varpositional bugfixes now that they are handled in makefun"},{"location":"changelog/#143-bugfix-in-nested-mode-under-python-2","text":"In python 2, when nested mode was used in a context where the signature contains a var-positional argument, a TypeError was raised ; this is now fixed. Fixes #13 .","title":"1.4.3 - Bugfix in nested mode under python 2"},{"location":"changelog/#142-bugfix-in-flat-mode-under-python-2","text":"In python 2, when flat mode was used in a context where the signature contains a var-positional argument, the arguments were not correctly injected. Fixes #12 .","title":"1.4.2 - Bugfix in flat mode under python 2"},{"location":"changelog/#141-minor-default-symbols-improvement","text":"Removed the clunky Enum for symbols. Back to a normal class, with a custom __repr__ .","title":"1.4.1 - Minor default symbols improvement"},{"location":"changelog/#140-minor-dependency-version-update","text":"Now relying on makefun>=1.5.0 where arg names changed a bit.","title":"1.4.0 - Minor dependency version update"},{"location":"changelog/#130-predefined-disambiguators-and-init-file-fix","text":"We now provide predefined disambiguators with_parenthesis and no_parenthesis . Fixes #8 . Fixed KeyError when the signature contains **kwargs . Fixes #9 . Fixed issue when the signature only contains **kwargs . Fixes #10 Fixed static checker problem in PyCharm with the symbols (it came back when we moved to an Enum) Improved exception re-raising in flat mode. Minor: fixed init file.","title":"1.3.0 - Predefined disambiguators and init file fix"},{"location":"changelog/#121-flat-and-double-flat-symbols-additional-protection-and-bugfix","text":"Default-value symbols DECORATED , WRAPPED , F_ARGS and F_KWARGS now have a nicer representation. Fixes #7 . When a symbol is used in a signature where it can not be safely injected as keyword argument, an InvalidSignatureError is now raised. Fixes #6 .","title":"1.2.1 - Flat and double flat symbols: additional protection and bugfix"},{"location":"changelog/#120-dependency-update-for-important-fix","text":"makefun>=1.4.0 is now required, as it fixes a major issue: #5","title":"1.2.0 - Dependency update for important fix"},{"location":"changelog/#111-symbols-are-not-classes-anymore","text":"Default-value symbols DECORATED , WRAPPED , F_ARGS and F_KWARGS are now objects and not classes any more. This prevents IDE to flag the corresponding argument as being misused (not iterable...). Fixes #4 .","title":"1.1.1 - Symbols are not classes anymore"},{"location":"changelog/#110-dependency-update","text":"The double-flat mode now relies on @makefun.wraps , from makefun>=1.3.0 . Fixes #3 . Updated documentation accordingly.","title":"1.1.0 - Dependency update"},{"location":"changelog/#100-refactoring-new-double-flat-mode-api-changes-documentation","text":"API changes: Added support for a new \"double-flat\" mode so that users can create decorators creating signature-preserving function wrappers with zero level of nesting. Fixes #2 . Generated var-positional name for kw-only methods is now '*_' can_first_arg_be_ambiguous parameter removed completely, it was too complex to use. callable_or_cls_firstarg_disambiguator renamed custom_disambiguator to be more intuitive wraps argument renamed flat_mode_decorated_name . It was too similar to the wording used in functools, and specific to the flat mode only. Fixes #1 . Improved behaviour Now the flat mode behaves exactly like nested mode concerning signature-related TypeError . This is because when you use the flat mode we now generate a nested mode function with a true signature. Now the exposed decorator uses the __wrapped__ trick to expose Major refactoring for code readability: Submodules are now consistent and readable. In particular utils_disambiguation now provides a clear disambiguate_call method, and util_modes provides a clear make_decorator_spec to handle all the per-mode specificity and always come back to a nested case before going further. removed a case in the main module (var-positional) as it was completely covered by the general case. Information is now passed as objects through the various functions, using two main classes SignatureInfo (for static information) and DecoratorUsageInfo (for dynamic/usage information). The information is computed in a lazy way for each to avoid unnecessary signature binding for example. Major documentation update.","title":"1.0.0 - Refactoring + New \"double-flat\" mode + API changes + documentation"},{"location":"changelog/#050-first-version","text":"Fully functional with 100+ tests.","title":"0.5.0 - First version"},{"location":"disambiguation/","text":"Disambiguation principles \u00b6 As stated in the introduction , without language modification (see proposal ) or additional knowledge or source code introspection, python is just not capable of detecting that @say_hello(foo) is different from @say_hello applied to function foo without parenthesis. However there are well-known \"tricks\" to perform a disambiguation that covers most standard cases. decopatch is basically a collection of such tricks. Some of them are static, based on your decorator's signature, and some others are dynamic, based on the received arguments. This section explains what happens behind the scenes. The reader is encouraged to get familiar with the basic decopatch principles first by reading the introduction . In particular the two main development styles (nested and flat) are assumed to be understood. All examples below use the \"flat\" style, but the equivalent \"nested\" style would lead to the exact same result. 1- no-args decorators \u00b6 It is probably quite useless to use decopatch if your decorator has no arguments, except if you wish to easily support with- and without- parenthesis usage. This is how you can do it from decopatch import decorator , DECORATED @decorator def replace_with_hello ( f = DECORATED ): \"\"\" Decorator to replace anything with the 'hello' string \"\"\" return 'hello' You can of course test that it works fine: @replace_with_hello # no parenthesis def foo (): pass assert foo == 'hello' @replace_with_hello () # with parenthesis def foo (): pass assert foo == 'hello' In this particular case, decopatch does not expose a decorator with no arguments as you would expect, but it instead adds a \"dummy\" var-positional argument named _ , so that both with- and without- parenthesis usages are supported: >>> help(replace_with_hello) Help on function replace_with_hello in module ...: replace_with_hello(*_) Decorator to replace anything by the 'hello' string. If your users try to input arguments they will get a TypeError , except if they provide a single argument that is a callable or a class. In that case we have no means to disambiguate so we prefer to consider that this is a no-parenthesis usage, rather than trying complex disambiguation tricks. After all, your decorator is supposed to have no arguments :) replace_with_hello ( 1 ) # TypeError: function 'replace_with_hello' does not accept any argument. replace_with_hello ( print ) # no error ! See create_no_args_decorator in the source code for details. 2- keyword-only decorators \u00b6 1+ mandatory argument(s) \u00b6 If your decorator is keyword-only and has at least one mandatory argument : @decorator def replace_with ( * , replacement , f = DECORATED ): \"\"\" Decorator to replace anything with the <replacement> object. \"\"\" return replacement then everything is very easy for decopatch : it can expose your desired signature directly, users have no way to use it in an ambiguous manner, and a successful call will always be a with-parenthesis call. @replace_with ( replacement = 'hello' ) def foo (): pass assert foo == 'hello' replace_with ( 1 ) # TypeError: replace_with() takes 0 positional arguments replace_with ( str ) # TypeError: replace_with() takes 0 positional arguments See create_kwonly_decorator in the source code for details. 0 mandatory arguments \u00b6 If your decorator is keyword-only but has no mandatory argument : @decorator def replace_with ( * , replacement = 'hello' , f = DECORATED ): \"\"\" Decorator to replace anything with the <replacement> object. Default value is 'hello'. \"\"\" return replacement decopatch automatically adds a dummy var-positional argument named _ to the decorator signature so that your users can use it without arguments nor parenthesis: >>>help(replace_with) Help on function replace_with in module ...: replace_with(*_, replacement='hello') Decorator to replace anything with the <replacement> object. Then disambiguations are handled similarly to all other decorators (see below). See create_kwonly_decorator in the source code for details. 3- General case \u00b6 In the general case, disambiguation is made of two phases: first eliminating cases for which we have no doubts, then handling the remaining ambiguous cases. See disambiguate_call in the source code for details. a- Eliminating easy cases: we look at the number of positional and keyword arguments to eliminate cases that can not be a \"no-parenthesis\" usage we look at the value of the argument received to eliminate further: for example, if it is not a callable nor a class it is has to be provided with parenthesis. b- Handling still-ambiguous cases If we reach this part, that's because the first argument in the signature is a callable or a class, positional (or in python 2, is different from its default value), and it is the only one (or in python 2, the only one different from its default value) Note: python 2 behaviour should align when this funcsigs issue is fixed. In that scenario, decopatch makes the least worst guess: this is probably a no-parenthesis call . Because it is not very probable that your decorator is made to receive a function or a class as first argument. However you can change this default behaviour, by providing additional knowledge. First, you can explicitly declare that your decorator is a function-only or class-only decorator , by using @decorator(is_function_decorator=False) or (is_class_decorator=False) , or by using the shortcut aliases @class_decorator or @function_decorator respectively. In that case, decopatch will know that for example a class received by a function decorator is probably a with-parenthesis first argument. You can also provide an explicit disambiguation function ( custom_disambiguator=... ). This function will only be called for ambiguous cases. It should accept a single argument (the first argument's value), and should return either FirstArgDisambiguation.is_normal_arg or FirstArgDisambiguation.is_decorated_target . It can also return FirstArgDisambiguation.is_ambiguous if it can not decide ; in which case an exception will be raised. For your convenience, you can use the predefined disambiguators custom_disambiguator=with_parenthesis or custom_disambiguator=no_parenthesis if an ambiguous first argument should always be handled as an arg (with parenthesis) or as the decorated target (no parenthesis) respectively. Finally as a last resort scenario you can enable introspection ( enable_stack_introspection=True ). This beta feature seems to only work reliably with function decorators, because inspect.stack does not provide a reliable way to access the decorator usage source code line when used on a class. Note that it seems to fail when used with python >=3.8 .","title":"Disambiguation principes"},{"location":"disambiguation/#disambiguation-principles","text":"As stated in the introduction , without language modification (see proposal ) or additional knowledge or source code introspection, python is just not capable of detecting that @say_hello(foo) is different from @say_hello applied to function foo without parenthesis. However there are well-known \"tricks\" to perform a disambiguation that covers most standard cases. decopatch is basically a collection of such tricks. Some of them are static, based on your decorator's signature, and some others are dynamic, based on the received arguments. This section explains what happens behind the scenes. The reader is encouraged to get familiar with the basic decopatch principles first by reading the introduction . In particular the two main development styles (nested and flat) are assumed to be understood. All examples below use the \"flat\" style, but the equivalent \"nested\" style would lead to the exact same result.","title":"Disambiguation principles"},{"location":"disambiguation/#1-no-args-decorators","text":"It is probably quite useless to use decopatch if your decorator has no arguments, except if you wish to easily support with- and without- parenthesis usage. This is how you can do it from decopatch import decorator , DECORATED @decorator def replace_with_hello ( f = DECORATED ): \"\"\" Decorator to replace anything with the 'hello' string \"\"\" return 'hello' You can of course test that it works fine: @replace_with_hello # no parenthesis def foo (): pass assert foo == 'hello' @replace_with_hello () # with parenthesis def foo (): pass assert foo == 'hello' In this particular case, decopatch does not expose a decorator with no arguments as you would expect, but it instead adds a \"dummy\" var-positional argument named _ , so that both with- and without- parenthesis usages are supported: >>> help(replace_with_hello) Help on function replace_with_hello in module ...: replace_with_hello(*_) Decorator to replace anything by the 'hello' string. If your users try to input arguments they will get a TypeError , except if they provide a single argument that is a callable or a class. In that case we have no means to disambiguate so we prefer to consider that this is a no-parenthesis usage, rather than trying complex disambiguation tricks. After all, your decorator is supposed to have no arguments :) replace_with_hello ( 1 ) # TypeError: function 'replace_with_hello' does not accept any argument. replace_with_hello ( print ) # no error ! See create_no_args_decorator in the source code for details.","title":"1- no-args decorators"},{"location":"disambiguation/#2-keyword-only-decorators","text":"","title":"2- keyword-only decorators"},{"location":"disambiguation/#1-mandatory-arguments","text":"If your decorator is keyword-only and has at least one mandatory argument : @decorator def replace_with ( * , replacement , f = DECORATED ): \"\"\" Decorator to replace anything with the <replacement> object. \"\"\" return replacement then everything is very easy for decopatch : it can expose your desired signature directly, users have no way to use it in an ambiguous manner, and a successful call will always be a with-parenthesis call. @replace_with ( replacement = 'hello' ) def foo (): pass assert foo == 'hello' replace_with ( 1 ) # TypeError: replace_with() takes 0 positional arguments replace_with ( str ) # TypeError: replace_with() takes 0 positional arguments See create_kwonly_decorator in the source code for details.","title":"1+ mandatory argument(s)"},{"location":"disambiguation/#0-mandatory-arguments","text":"If your decorator is keyword-only but has no mandatory argument : @decorator def replace_with ( * , replacement = 'hello' , f = DECORATED ): \"\"\" Decorator to replace anything with the <replacement> object. Default value is 'hello'. \"\"\" return replacement decopatch automatically adds a dummy var-positional argument named _ to the decorator signature so that your users can use it without arguments nor parenthesis: >>>help(replace_with) Help on function replace_with in module ...: replace_with(*_, replacement='hello') Decorator to replace anything with the <replacement> object. Then disambiguations are handled similarly to all other decorators (see below). See create_kwonly_decorator in the source code for details.","title":"0 mandatory arguments"},{"location":"disambiguation/#3-general-case","text":"In the general case, disambiguation is made of two phases: first eliminating cases for which we have no doubts, then handling the remaining ambiguous cases. See disambiguate_call in the source code for details. a- Eliminating easy cases: we look at the number of positional and keyword arguments to eliminate cases that can not be a \"no-parenthesis\" usage we look at the value of the argument received to eliminate further: for example, if it is not a callable nor a class it is has to be provided with parenthesis. b- Handling still-ambiguous cases If we reach this part, that's because the first argument in the signature is a callable or a class, positional (or in python 2, is different from its default value), and it is the only one (or in python 2, the only one different from its default value) Note: python 2 behaviour should align when this funcsigs issue is fixed. In that scenario, decopatch makes the least worst guess: this is probably a no-parenthesis call . Because it is not very probable that your decorator is made to receive a function or a class as first argument. However you can change this default behaviour, by providing additional knowledge. First, you can explicitly declare that your decorator is a function-only or class-only decorator , by using @decorator(is_function_decorator=False) or (is_class_decorator=False) , or by using the shortcut aliases @class_decorator or @function_decorator respectively. In that case, decopatch will know that for example a class received by a function decorator is probably a with-parenthesis first argument. You can also provide an explicit disambiguation function ( custom_disambiguator=... ). This function will only be called for ambiguous cases. It should accept a single argument (the first argument's value), and should return either FirstArgDisambiguation.is_normal_arg or FirstArgDisambiguation.is_decorated_target . It can also return FirstArgDisambiguation.is_ambiguous if it can not decide ; in which case an exception will be raised. For your convenience, you can use the predefined disambiguators custom_disambiguator=with_parenthesis or custom_disambiguator=no_parenthesis if an ambiguous first argument should always be handled as an arg (with parenthesis) or as the decorated target (no parenthesis) respectively. Finally as a last resort scenario you can enable introspection ( enable_stack_introspection=True ). This beta feature seems to only work reliably with function decorators, because inspect.stack does not provide a reliable way to access the decorator usage source code line when used on a class. Note that it seems to fail when used with python >=3.8 .","title":"3- General case"},{"location":"long_description/","text":"decopatch \u00b6 python decorators made easy. The documentation for users is available here: https://smarie.github.io/python-decopatch/ A readme for developers is available here: https://github.com/smarie/python-decopatch","title":"decopatch"},{"location":"long_description/#decopatch","text":"python decorators made easy. The documentation for users is available here: https://smarie.github.io/python-decopatch/ A readme for developers is available here: https://github.com/smarie/python-decopatch","title":"decopatch"},{"location":"motivation/","text":"Motivation \u00b6 This page explains why I felt frustrated by the current tools that we developers have at our disposal to develop decorators in python, and eventually why I ended-up writing decopatch . Problem \u00b6 In python, a decorator used without arguments such as @say_hello # (1) no-parenthesis def foo ( a , b ): pass requires a completely different implementation code than @say_hello () # (2) empty-parenthesis def foo ( a , b ): pass Indeed (1) requires say_hello to directly return a replacement for the decorated object (in that case function foo ), while (2) requires say_hello to return a function that returns a replacement for the decorated object ! This is one more level of nesting. If you wish to handle both situations in a robust way, you end-up having to design some ridiculously complex code , relying on some well-known \"tricks\" based either on checking the type or existence of first argument provided. For example: def say_hello ( f = None ): if f is not None : # this is (1) @say_hello (without parenthesis) # we have to directly return a replacement for f def new_f ( ... ): ... return new_f else : # this is (2) @say_hello() (empty parenthesis) # we have to return a decorator function def _decorate ( f ): def new_f ( ... ): ... return new_f return _decorate Unfortunately, the 'trick' to use is different for almost every type of decorator signature (var-args, keyword-only, all-optional, ...). So if you change your mind about your API during development time (this often happens, at least to me :)), you end up having to change this useless piece of code several times! Solution \u00b6 decopatch provides a simple way to solve this issue. It always uses the best \"trick\", so that you do not have to care, you just implement one case: from decopatch import function_decorator @function_decorator def say_hello (): def _decorate ( f ): def new_f ( ... ): ... return new_f return _decorate To ease things even more, decopatch also supports a flat mode: from decopatch import function_decorator , DECORATED @function_decorator def say_hello ( f = DECORATED ): def new_f ( ... ): ... return new_f In both cases, generated decorators have a proper help and signature , so users do not see the difference, the choice of mode is a matter of development style. Why something new ? \u00b6 As opposed to the great decorator and wrapt libraries, decopatch does not try at the same time to help you create decorators and (signature-preserving) function wrappers. In my opinion creating function wrappers is a completely independent topic, you can wish to do it in with a decorator OR without. Nevertheless since it is an important use case, the documentation shows how to do it . If you're interested in this topic, see makefun , my fork of decorator 's core engine supporting additional use cases such as signature modification. Also, note that (at the time of writing so with decorator 4.3.2 and wrapt 1.11.1): none of wrapt and decorator preserve the exposed decorator's signature: they both rely on an extra optional argument ( func=None and wrapped=None respectively). decorator relies on the __wrapped__ special field to trick the signature module about the true signature of the decorator. You can check it by deleting this field on your decorator, and query its signature again: you will see the true signature of your decorator (the one seen by the python interpreter when calling the decorator). none of decorator and wrapt handle the no-parenthesis case natively. wrapt explains which lines of codes you have to enter while with decorator you have to write the parenthesis. Could we solve this directly in the python language instead ? \u00b6 That would be great ! See my PEP proposal draft .","title":"Motivation"},{"location":"motivation/#motivation","text":"This page explains why I felt frustrated by the current tools that we developers have at our disposal to develop decorators in python, and eventually why I ended-up writing decopatch .","title":"Motivation"},{"location":"motivation/#problem","text":"In python, a decorator used without arguments such as @say_hello # (1) no-parenthesis def foo ( a , b ): pass requires a completely different implementation code than @say_hello () # (2) empty-parenthesis def foo ( a , b ): pass Indeed (1) requires say_hello to directly return a replacement for the decorated object (in that case function foo ), while (2) requires say_hello to return a function that returns a replacement for the decorated object ! This is one more level of nesting. If you wish to handle both situations in a robust way, you end-up having to design some ridiculously complex code , relying on some well-known \"tricks\" based either on checking the type or existence of first argument provided. For example: def say_hello ( f = None ): if f is not None : # this is (1) @say_hello (without parenthesis) # we have to directly return a replacement for f def new_f ( ... ): ... return new_f else : # this is (2) @say_hello() (empty parenthesis) # we have to return a decorator function def _decorate ( f ): def new_f ( ... ): ... return new_f return _decorate Unfortunately, the 'trick' to use is different for almost every type of decorator signature (var-args, keyword-only, all-optional, ...). So if you change your mind about your API during development time (this often happens, at least to me :)), you end up having to change this useless piece of code several times!","title":"Problem"},{"location":"motivation/#solution","text":"decopatch provides a simple way to solve this issue. It always uses the best \"trick\", so that you do not have to care, you just implement one case: from decopatch import function_decorator @function_decorator def say_hello (): def _decorate ( f ): def new_f ( ... ): ... return new_f return _decorate To ease things even more, decopatch also supports a flat mode: from decopatch import function_decorator , DECORATED @function_decorator def say_hello ( f = DECORATED ): def new_f ( ... ): ... return new_f In both cases, generated decorators have a proper help and signature , so users do not see the difference, the choice of mode is a matter of development style.","title":"Solution"},{"location":"motivation/#why-something-new","text":"As opposed to the great decorator and wrapt libraries, decopatch does not try at the same time to help you create decorators and (signature-preserving) function wrappers. In my opinion creating function wrappers is a completely independent topic, you can wish to do it in with a decorator OR without. Nevertheless since it is an important use case, the documentation shows how to do it . If you're interested in this topic, see makefun , my fork of decorator 's core engine supporting additional use cases such as signature modification. Also, note that (at the time of writing so with decorator 4.3.2 and wrapt 1.11.1): none of wrapt and decorator preserve the exposed decorator's signature: they both rely on an extra optional argument ( func=None and wrapped=None respectively). decorator relies on the __wrapped__ special field to trick the signature module about the true signature of the decorator. You can check it by deleting this field on your decorator, and query its signature again: you will see the true signature of your decorator (the one seen by the python interpreter when calling the decorator). none of decorator and wrapt handle the no-parenthesis case natively. wrapt explains which lines of codes you have to enter while with decorator you have to write the parenthesis.","title":"Why something new ?"},{"location":"motivation/#could-we-solve-this-directly-in-the-python-language-instead","text":"That would be great ! See my PEP proposal draft .","title":"Could we solve this directly in the python language instead ?"},{"location":"pep_proposal/","text":"PEP proposal draft \u00b6 As already stated in this documentation, there is as of python 3.7, absolutely no way to detect that the usage of @say_hello in: @say_hello ( foo ) def bar (): pass is different from @say_hello def foo (): pass As we saw in the disambiguation principles , a library can disambiguate only if the decorator developer provides additional knowledge. Below are a few ideas that would fix this problem once and for all (hopefully!) directly in the python language instead. Feedback welcome ! 1- breaking backwards compatibility \u00b6 The easiest way to fix the no-parenthesis case directly in the language would be to automatically redirect all decorator usage without parenthesis, to empty-parenthesis. So if you have a set_hello_tag(tag='world') decorator, if you use it without parenthesis: @set_hello_tag def foo (): pass the python language interpreter would interprete it exactly the same way than @set_hello_tag () def foo (): pass In other words, using a decorator with the @ syntax and without parenthesis would simply be an alias for the same usage with empty parenthesis. Implementation would therefore be extremely easy: for all decorators, you would always code it in a \"nested\" way: def set_hello_tag ( tag = 'world' ): def decorate ( f ): setattr ( f , 'hello' , tag ) # set a hello=<tag> tag on the decorated f return f return decorate Drawbacks : this change in the python interpreter behaviour would obviously break compatibility for legacy decorators that did not support arguments at all, such as this one: def set_helloworld_tag ( f ): setattr ( f , 'hello' , 'world' ) # set a hello=world tag on the decorated f return f 2- preserving backwards compatibility \u00b6 If we need to preserve backwards compatibility, then we need to make the new mechanism optional, so that developers explicitly choose to use it. My suggestion would be to introduce a new @decorator_factory decorator in the stdlib , that developers would use to declare that they are ok with redirecting all no-parenthesis usages to with-empty-parenthesis usages. Note that I use the term \"factory\" because some users use it to distinguish between the no-argument ones (decorators) and the with-argument ones (decorator factories). This is how you would create a set_hello_tag decorator: @decorator_factory def set_hello_tag ( tag = 'world' ): def decorate ( f ): setattr ( f , 'hello' , tag ) # set a hello tag on the decorated f return f return decorate The explicit @decorator_factory annotation would make the interpreter/stdlib redirect all occurences of @set_hello_tag (without parenthesis) into explicit @set_hello_tag() (with empty parenthesis). Notes: if this is a too low-level feature it might require a dedicated language symbol instead of a \"normal\" decorator ; but it seems overkill - it would be better if we can avoid creating a new language element. alternatively or in addition, the python stdlib could provide a method that would return True if and only if a given frame is a no-parenthesis decorator call. This method, for example named inspect.is_decorator_call(frame=None) , could then be used by the various helper libraries, including decopatch . Follow-up After proposing the above to the python-ideas mailing list, it seems that people were not as interested as I thought they would be. I therefore proposed a very minimal feature in the python bug tracker (the inspect.is_decorator_call(frame) option discussed above). At least with this, everyone would be able to solve the issue easily himself, like this: from inspect import is_decorator_call def set_hello_tag ( tag = 'world' ): if is_decorator_call (): # called without parenthesis! # the decorated object is `tag` return set_hello_tag ()( tag ) # note that `is_decorator_call` should not return True for this call else : def decorate ( f ): setattr ( f , 'hello' , tag ) # set a hello tag on the decorated f return f return decorate Note that is_decorator_call should not return True in nested frames, just for the immediate frame in a decorator application.","title":"PEP proposal"},{"location":"pep_proposal/#pep-proposal-draft","text":"As already stated in this documentation, there is as of python 3.7, absolutely no way to detect that the usage of @say_hello in: @say_hello ( foo ) def bar (): pass is different from @say_hello def foo (): pass As we saw in the disambiguation principles , a library can disambiguate only if the decorator developer provides additional knowledge. Below are a few ideas that would fix this problem once and for all (hopefully!) directly in the python language instead. Feedback welcome !","title":"PEP proposal draft"},{"location":"pep_proposal/#1-breaking-backwards-compatibility","text":"The easiest way to fix the no-parenthesis case directly in the language would be to automatically redirect all decorator usage without parenthesis, to empty-parenthesis. So if you have a set_hello_tag(tag='world') decorator, if you use it without parenthesis: @set_hello_tag def foo (): pass the python language interpreter would interprete it exactly the same way than @set_hello_tag () def foo (): pass In other words, using a decorator with the @ syntax and without parenthesis would simply be an alias for the same usage with empty parenthesis. Implementation would therefore be extremely easy: for all decorators, you would always code it in a \"nested\" way: def set_hello_tag ( tag = 'world' ): def decorate ( f ): setattr ( f , 'hello' , tag ) # set a hello=<tag> tag on the decorated f return f return decorate Drawbacks : this change in the python interpreter behaviour would obviously break compatibility for legacy decorators that did not support arguments at all, such as this one: def set_helloworld_tag ( f ): setattr ( f , 'hello' , 'world' ) # set a hello=world tag on the decorated f return f","title":"1- breaking backwards compatibility"},{"location":"pep_proposal/#2-preserving-backwards-compatibility","text":"If we need to preserve backwards compatibility, then we need to make the new mechanism optional, so that developers explicitly choose to use it. My suggestion would be to introduce a new @decorator_factory decorator in the stdlib , that developers would use to declare that they are ok with redirecting all no-parenthesis usages to with-empty-parenthesis usages. Note that I use the term \"factory\" because some users use it to distinguish between the no-argument ones (decorators) and the with-argument ones (decorator factories). This is how you would create a set_hello_tag decorator: @decorator_factory def set_hello_tag ( tag = 'world' ): def decorate ( f ): setattr ( f , 'hello' , tag ) # set a hello tag on the decorated f return f return decorate The explicit @decorator_factory annotation would make the interpreter/stdlib redirect all occurences of @set_hello_tag (without parenthesis) into explicit @set_hello_tag() (with empty parenthesis). Notes: if this is a too low-level feature it might require a dedicated language symbol instead of a \"normal\" decorator ; but it seems overkill - it would be better if we can avoid creating a new language element. alternatively or in addition, the python stdlib could provide a method that would return True if and only if a given frame is a no-parenthesis decorator call. This method, for example named inspect.is_decorator_call(frame=None) , could then be used by the various helper libraries, including decopatch . Follow-up After proposing the above to the python-ideas mailing list, it seems that people were not as interested as I thought they would be. I therefore proposed a very minimal feature in the python bug tracker (the inspect.is_decorator_call(frame) option discussed above). At least with this, everyone would be able to solve the issue easily himself, like this: from inspect import is_decorator_call def set_hello_tag ( tag = 'world' ): if is_decorator_call (): # called without parenthesis! # the decorated object is `tag` return set_hello_tag ()( tag ) # note that `is_decorator_call` should not return True for this call else : def decorate ( f ): setattr ( f , 'hello' , tag ) # set a hello tag on the decorated f return f return decorate Note that is_decorator_call should not return True in nested frames, just for the immediate frame in a decorator application.","title":"2- preserving backwards compatibility"},{"location":"usage_details/","text":"Usage details \u00b6 WARNING: THIS IS AN OLD PAGE WITH OUTDATED INFORMATION ! PLEASE IGNORE IT ! a- Flat mode \u00b6 In this mode the decorator is implemented as a function, that should return the replacement for the decorated item. To create a decorator you have to do two things: use @function_decorator , @class_decorator or @decorator on your implementation function declare which variable represents the injected decorated item by using the DECORATED keyword as its default value. Note: if you can not or do not want to add the DECORATED default value, you can specify the variable name explicitly with decorated=<argname> . 1- Simple with mandatory arg \u00b6 Let's create a simple @add_tag decorator that adds a tag on the decorated function: from decopatch import function_decorator , DECORATED @function_decorator def add_tag ( tag , f = DECORATED ): \"\"\" This decorator adds the 'my_tag' tag on the decorated function, with the value provided as argument :param tag: the tag value to set :param f: represents the decorated item. Automatically injected. :return: \"\"\" setattr ( f , 'my_tag' , tag ) return f You can test that your new @add_tag decorator works: @add_tag ( 'hello' ) def foo (): return # let's check that the `foo` function has been correctly decorated assert foo . my_tag == 'hello' And also that using your decorator without argument raises an error as expected: @add_tag def foo (): return yields TypeError: add_tag() missing 1 required positional argument: 'tag' . Finally, note that calling the decorator with a callable as first argument is even correctly handled: @add_tag ( print ) def foo (): return assert foo . my_tag == print # works ! 2- Same with all-optional args \u00b6 Let's modify the above example so that the argument is optional: @function_decorator def add_tag ( tag = 'tag!' , f = DECORATED ): setattr ( f , 'my_tag' , tag ) return f You can check that everything works as expected: @add_tag ( 'hello' ) # normal arg def foo (): return assert foo . my_tag == 'hello' @add_tag ( tag = 'hello' ) # normal kwarg def foo (): return assert foo . my_tag == 'hello' @add_tag # no parenthesis def foo (): return assert foo . my_tag == 'tag!' @add_tag () # empty parenthesis def foo (): return assert foo . my_tag == 'tag!' @add_tag ( print ) # callable as first arg def foo (): return assert foo . my_tag == print @add_tag ( tag = print ) # callable as first kwarg def foo (): return assert foo . my_tag == print 3- Function wrapper creator \u00b6 In real-world applications you often wish to not only modify the decorated item, but to replace it with something else. A typical use case is the creation of a function wrapper , for example to add behaviours to a function when decorating it. The great wrapt and decorator libraries have been designed mostly to cover this purpose, but they blend it quite tightly to the decorator creation. Below we show that the same result can be obtained by combining two distinct libraries: decopatch to create the decorator, and the library of your choice for the signature-preserving wrapper. In this example we use makefun . Let's create a @say_hello decorator, that prints a message to stdout before each call to the decorated function. from decopatch import function_decorator , DECORATED from makefun import with_signature @function_decorator def say_hello ( person = \"world\" , f = DECORATED ): \"\"\" This decorator modifies the decorated function so that a nice hello message is printed before the call. :param person: the person name in the print message. Default = \"world\" :param f: represents the decorated item. Automatically injected. :return: a modified version of `f` that will print a msg before executing \"\"\" # create a wrapper of f that will do the print before call # we rely on `makefun.with_signature` to preserve signature @with_signature ( f ) def new_f ( * args , ** kwargs ): nonlocal person print ( \"hello, %s !\" % person ) # say hello return f ( * args , ** kwargs ) # call f # return the new function return new_f Once again, you can check that all call modes are properly implemented: @say_hello def foo (): print ( \"<executing foo>\" ) foo () @say_hello () def bar (): print ( \"<executing bar>\" ) bar () @say_hello ( \"you\" ) def custom (): print ( \"<executing custom>\" ) custom () yields hello, world ! <executing foo> hello, world ! <executing bar> hello, you ! <executing custom> nonlocal in python 2 In python 2 the nonlocal keyword from PEP3104 is not available. See this workaround 4- Class decorator \u00b6 You can similarly use @class_decorator to create a decorator that works for classes. 5- Class+Function decorator \u00b6 Both @function_decorator and @class_decorator are actually user-friendly presets for the more generic @decorator . If you wish to write a decorator that can be used both for functions and classes, you can use it. b- Nested mode \u00b6 In nested mode you write your decorator's signature thinking about what the user will have to enter. So for example if you wish to create @say_hello(person) you will define def say_hello(person) . In that case your function has to return a function. In other words, nested mode is equivalent to how you write python decorators with arguments today, except that you do not have to write anything special to handle the case where your decorator is used without parenthesis. It is silently redirected to the case where it is used with parenthesis. To write decorators in this mode, you only have to decorate them with @function_decorator , @class_decorator or @decorator . 1- Simple with mandatory arg \u00b6 We can reproduce the same example than above, in this alternate style: @function_decorator def add_tag ( tag ): \"\"\" This decorator adds the 'my_tag' tag on the decorated function, with the value provided as argument :param tag: the tag value to set :return: \"\"\" def replace_f ( f ): setattr ( f , 'my_tag' , tag ) return f return replace_f You can test that your new @add_tag decorator works: @add_tag ( 'hello' ) def foo (): return # let's check that the `foo` function has been correctly decorated assert foo . my_tag == 'hello' c- Behind the scenes \u00b6 When you use @function_decorator or the like, your function is dynamically replaced with another one with the same signature (if you're in nested mode) or where the f parameter is removed (if you're in flat mode). You can see it by using help on your function, or by looking at its signature: help ( say_hello ) from inspect import signature print ( \"Signature: %s \" % signature ( say_hello )) yields Help on function say_hello in module my_module: say_hello ( person = 'world' ) This decorator modifies the decorated function so that a nice hello message is printed before the call. :param person: the person name in the print message. Default = \"world\" :return: Signature: ( person = 'world' ) c- Advanced topics \u00b6 1 mandatory either InvalidMandatoryArgError : function 'add_tag' requires a mandatory argument 'tag' . Provided value '<function foo at 0x00000160858ED510>' does not pass its validation criteria Note that this error is a dedicated subclass of TypeError , and not the native TypeError that python raises when a function is called without a mandatory argument. This is mostly for testability reasons, to make sure that the library worked correctly. By default you cannot use a callable as first mandatory argument : @add_tag ( print ) def foo (): return raises InvalidMandatoryArgError : function 'add_tag' requires a mandatory argument 'tag' . Provided value '<built-in function print>' does not pass its validation criteria Indeed there is absolutely no way in the python language to disambiguate this case with the previous one without user-provided disambiguation rules. Since we wanted to avoid silent incorrect behaviour in the previous (no-parenthesis) usage, then the consequence is that we have an error in this usage that seems legitimate. It is very easy to fix this : if you wish to accept callables/classes as first mandatory argument, the simplest thing to do is to force keyword usage (adding a star as first argument): @function_decorator def add_tag ( * , tag , f = DECORATED ): \"\"\" We use the * in the signature to disambiguate \"\"\" setattr ( f , 'my_tag' , tag ) return f Now your decorator will be entirely not ambiguous, users will be able to pass callables to it while still getting an error in case they use it without arguments. @add_tag ( tag = print ) # >> disambiguated: now works correctly def foo (): return assert foo . my_tag == print @add_tag # >> disambiguated: raises the standard TypeError now def foo (): return Note: if you do not want to use this trick, there are other, more cumbersome ways to perform the disambiguation. See this section on first argument disambiguation . 1 optional Let's modify the previous decorator so that its tag argument is optional: @function_decorator def add_tag ( tag = 'tag!' , f = DECORATED ): setattr ( f , 'my_tag' , tag ) return f You see that decopath does not accept it: AmbiguousDecoratorDefinitionError : This decorator is ambiguous because it has only optional arguments . Please provide an explicit protection . Indeed this is a very ambiguous decorator: the decorator can be used without arguments: @add_tag or @add_tag() but it can also be used with arguments: @add_tag('hello') . In particular it can be used with a callable as first argument such as in @add_tag(print) The python language is not able to see the difference between using @add_tag to decorate a function named print , and @add_tag(print) applied to decorate another function: # the following two usages are programmatically undetectable # except if we cheat and look at the source code @add_tag def print (): return @add_tag ( print ) def another (): return , and therefore we ask you to explicitly protect your decorator. Once again you can use the \"keyword-only\" trick, or if you have a good reason not to do it, see this section on first argument disambiguation . Wrapper Note that this time usage without arguments is permitted, as long as the value provided for the first argument is not a callable - as that would be ambiguous. In very rare cases, you want to create a decorator that accepts to be called with a single argument (i.e. it has a single mandatory argument, or only optional ones) where the first argument in the signature, except the DECORATED one, is a callable or a class. For example the following dummy decorator will replace the decorated function with its argument: @decorator def replace_with ( g , f = DECORATED ): \"\"\"replace the decorated function with its argument\"\"\" return g If you try to use it def foo (): pass @replace_with ( foo ) def bar (): pass Surprisingly it fails ! TypeError: replace_with () missing 1 required positional argument: 'g' This is because there is absolutely no way in the python language (if you know one, let me know !) to disambiguate the above case from the \"no-arg\" usage below: @replace_with def bar_no_arg (): pass Hopefully there are many workarounds if you use decopatch . The easiest ones consist in changing your decorator's signature: so that the first argument is keyword-only. This is the most reliable thing to do . For this, simply add a * before your first argument: @decorator def replace_with ( * , g , f = DECORATED ): # ... or if the first argument is optional, so that the callable/class is not the first in the list. In this case you have to either declare a type hint or perform manual validation in the code: @decorator def replace_with ( a : int = None , g = None , f = DECORATED ): # ... # or @decorator def replace_with ( a = None , g = None , f = DECORATED ): if not isinstance ( a , int ): raise TypeError () # ... or if the first argument is mandatory, so that it is not alone (at least two mandatory arguments) @decorator def replace_with ( g , a , f = DECORATED ): # ... If you can not afford a signature change, there are two other ways to work around this problem: change the default detector for first argument disambiguation. By default if a single argument is received, it will be assumed to be the true first arg (and not the decorator's target), if it is not a callable nor a class. If you are sure that a function of a certain type, or a class with certain caracteristics, can only be the argument and not the decorated object, then you can override this default logic. For example we could use @decorator(first_arg_disambiguator=lambda g: g in {foo}) in the above code.","title":"Usage details"},{"location":"usage_details/#usage-details","text":"WARNING: THIS IS AN OLD PAGE WITH OUTDATED INFORMATION ! PLEASE IGNORE IT !","title":"Usage details"},{"location":"usage_details/#a-flat-mode","text":"In this mode the decorator is implemented as a function, that should return the replacement for the decorated item. To create a decorator you have to do two things: use @function_decorator , @class_decorator or @decorator on your implementation function declare which variable represents the injected decorated item by using the DECORATED keyword as its default value. Note: if you can not or do not want to add the DECORATED default value, you can specify the variable name explicitly with decorated=<argname> .","title":"a- Flat mode"},{"location":"usage_details/#1-simple-with-mandatory-arg","text":"Let's create a simple @add_tag decorator that adds a tag on the decorated function: from decopatch import function_decorator , DECORATED @function_decorator def add_tag ( tag , f = DECORATED ): \"\"\" This decorator adds the 'my_tag' tag on the decorated function, with the value provided as argument :param tag: the tag value to set :param f: represents the decorated item. Automatically injected. :return: \"\"\" setattr ( f , 'my_tag' , tag ) return f You can test that your new @add_tag decorator works: @add_tag ( 'hello' ) def foo (): return # let's check that the `foo` function has been correctly decorated assert foo . my_tag == 'hello' And also that using your decorator without argument raises an error as expected: @add_tag def foo (): return yields TypeError: add_tag() missing 1 required positional argument: 'tag' . Finally, note that calling the decorator with a callable as first argument is even correctly handled: @add_tag ( print ) def foo (): return assert foo . my_tag == print # works !","title":"1- Simple with mandatory arg"},{"location":"usage_details/#2-same-with-all-optional-args","text":"Let's modify the above example so that the argument is optional: @function_decorator def add_tag ( tag = 'tag!' , f = DECORATED ): setattr ( f , 'my_tag' , tag ) return f You can check that everything works as expected: @add_tag ( 'hello' ) # normal arg def foo (): return assert foo . my_tag == 'hello' @add_tag ( tag = 'hello' ) # normal kwarg def foo (): return assert foo . my_tag == 'hello' @add_tag # no parenthesis def foo (): return assert foo . my_tag == 'tag!' @add_tag () # empty parenthesis def foo (): return assert foo . my_tag == 'tag!' @add_tag ( print ) # callable as first arg def foo (): return assert foo . my_tag == print @add_tag ( tag = print ) # callable as first kwarg def foo (): return assert foo . my_tag == print","title":"2- Same with all-optional args"},{"location":"usage_details/#3-function-wrapper-creator","text":"In real-world applications you often wish to not only modify the decorated item, but to replace it with something else. A typical use case is the creation of a function wrapper , for example to add behaviours to a function when decorating it. The great wrapt and decorator libraries have been designed mostly to cover this purpose, but they blend it quite tightly to the decorator creation. Below we show that the same result can be obtained by combining two distinct libraries: decopatch to create the decorator, and the library of your choice for the signature-preserving wrapper. In this example we use makefun . Let's create a @say_hello decorator, that prints a message to stdout before each call to the decorated function. from decopatch import function_decorator , DECORATED from makefun import with_signature @function_decorator def say_hello ( person = \"world\" , f = DECORATED ): \"\"\" This decorator modifies the decorated function so that a nice hello message is printed before the call. :param person: the person name in the print message. Default = \"world\" :param f: represents the decorated item. Automatically injected. :return: a modified version of `f` that will print a msg before executing \"\"\" # create a wrapper of f that will do the print before call # we rely on `makefun.with_signature` to preserve signature @with_signature ( f ) def new_f ( * args , ** kwargs ): nonlocal person print ( \"hello, %s !\" % person ) # say hello return f ( * args , ** kwargs ) # call f # return the new function return new_f Once again, you can check that all call modes are properly implemented: @say_hello def foo (): print ( \"<executing foo>\" ) foo () @say_hello () def bar (): print ( \"<executing bar>\" ) bar () @say_hello ( \"you\" ) def custom (): print ( \"<executing custom>\" ) custom () yields hello, world ! <executing foo> hello, world ! <executing bar> hello, you ! <executing custom> nonlocal in python 2 In python 2 the nonlocal keyword from PEP3104 is not available. See this workaround","title":"3- Function wrapper creator"},{"location":"usage_details/#4-class-decorator","text":"You can similarly use @class_decorator to create a decorator that works for classes.","title":"4- Class decorator"},{"location":"usage_details/#5-classfunction-decorator","text":"Both @function_decorator and @class_decorator are actually user-friendly presets for the more generic @decorator . If you wish to write a decorator that can be used both for functions and classes, you can use it.","title":"5- Class+Function decorator"},{"location":"usage_details/#b-nested-mode","text":"In nested mode you write your decorator's signature thinking about what the user will have to enter. So for example if you wish to create @say_hello(person) you will define def say_hello(person) . In that case your function has to return a function. In other words, nested mode is equivalent to how you write python decorators with arguments today, except that you do not have to write anything special to handle the case where your decorator is used without parenthesis. It is silently redirected to the case where it is used with parenthesis. To write decorators in this mode, you only have to decorate them with @function_decorator , @class_decorator or @decorator .","title":"b- Nested mode"},{"location":"usage_details/#1-simple-with-mandatory-arg_1","text":"We can reproduce the same example than above, in this alternate style: @function_decorator def add_tag ( tag ): \"\"\" This decorator adds the 'my_tag' tag on the decorated function, with the value provided as argument :param tag: the tag value to set :return: \"\"\" def replace_f ( f ): setattr ( f , 'my_tag' , tag ) return f return replace_f You can test that your new @add_tag decorator works: @add_tag ( 'hello' ) def foo (): return # let's check that the `foo` function has been correctly decorated assert foo . my_tag == 'hello'","title":"1- Simple with mandatory arg"},{"location":"usage_details/#c-behind-the-scenes","text":"When you use @function_decorator or the like, your function is dynamically replaced with another one with the same signature (if you're in nested mode) or where the f parameter is removed (if you're in flat mode). You can see it by using help on your function, or by looking at its signature: help ( say_hello ) from inspect import signature print ( \"Signature: %s \" % signature ( say_hello )) yields Help on function say_hello in module my_module: say_hello ( person = 'world' ) This decorator modifies the decorated function so that a nice hello message is printed before the call. :param person: the person name in the print message. Default = \"world\" :return: Signature: ( person = 'world' )","title":"c- Behind the scenes"},{"location":"usage_details/#c-advanced-topics","text":"1 mandatory either InvalidMandatoryArgError : function 'add_tag' requires a mandatory argument 'tag' . Provided value '<function foo at 0x00000160858ED510>' does not pass its validation criteria Note that this error is a dedicated subclass of TypeError , and not the native TypeError that python raises when a function is called without a mandatory argument. This is mostly for testability reasons, to make sure that the library worked correctly. By default you cannot use a callable as first mandatory argument : @add_tag ( print ) def foo (): return raises InvalidMandatoryArgError : function 'add_tag' requires a mandatory argument 'tag' . Provided value '<built-in function print>' does not pass its validation criteria Indeed there is absolutely no way in the python language to disambiguate this case with the previous one without user-provided disambiguation rules. Since we wanted to avoid silent incorrect behaviour in the previous (no-parenthesis) usage, then the consequence is that we have an error in this usage that seems legitimate. It is very easy to fix this : if you wish to accept callables/classes as first mandatory argument, the simplest thing to do is to force keyword usage (adding a star as first argument): @function_decorator def add_tag ( * , tag , f = DECORATED ): \"\"\" We use the * in the signature to disambiguate \"\"\" setattr ( f , 'my_tag' , tag ) return f Now your decorator will be entirely not ambiguous, users will be able to pass callables to it while still getting an error in case they use it without arguments. @add_tag ( tag = print ) # >> disambiguated: now works correctly def foo (): return assert foo . my_tag == print @add_tag # >> disambiguated: raises the standard TypeError now def foo (): return Note: if you do not want to use this trick, there are other, more cumbersome ways to perform the disambiguation. See this section on first argument disambiguation . 1 optional Let's modify the previous decorator so that its tag argument is optional: @function_decorator def add_tag ( tag = 'tag!' , f = DECORATED ): setattr ( f , 'my_tag' , tag ) return f You see that decopath does not accept it: AmbiguousDecoratorDefinitionError : This decorator is ambiguous because it has only optional arguments . Please provide an explicit protection . Indeed this is a very ambiguous decorator: the decorator can be used without arguments: @add_tag or @add_tag() but it can also be used with arguments: @add_tag('hello') . In particular it can be used with a callable as first argument such as in @add_tag(print) The python language is not able to see the difference between using @add_tag to decorate a function named print , and @add_tag(print) applied to decorate another function: # the following two usages are programmatically undetectable # except if we cheat and look at the source code @add_tag def print (): return @add_tag ( print ) def another (): return , and therefore we ask you to explicitly protect your decorator. Once again you can use the \"keyword-only\" trick, or if you have a good reason not to do it, see this section on first argument disambiguation . Wrapper Note that this time usage without arguments is permitted, as long as the value provided for the first argument is not a callable - as that would be ambiguous. In very rare cases, you want to create a decorator that accepts to be called with a single argument (i.e. it has a single mandatory argument, or only optional ones) where the first argument in the signature, except the DECORATED one, is a callable or a class. For example the following dummy decorator will replace the decorated function with its argument: @decorator def replace_with ( g , f = DECORATED ): \"\"\"replace the decorated function with its argument\"\"\" return g If you try to use it def foo (): pass @replace_with ( foo ) def bar (): pass Surprisingly it fails ! TypeError: replace_with () missing 1 required positional argument: 'g' This is because there is absolutely no way in the python language (if you know one, let me know !) to disambiguate the above case from the \"no-arg\" usage below: @replace_with def bar_no_arg (): pass Hopefully there are many workarounds if you use decopatch . The easiest ones consist in changing your decorator's signature: so that the first argument is keyword-only. This is the most reliable thing to do . For this, simply add a * before your first argument: @decorator def replace_with ( * , g , f = DECORATED ): # ... or if the first argument is optional, so that the callable/class is not the first in the list. In this case you have to either declare a type hint or perform manual validation in the code: @decorator def replace_with ( a : int = None , g = None , f = DECORATED ): # ... # or @decorator def replace_with ( a = None , g = None , f = DECORATED ): if not isinstance ( a , int ): raise TypeError () # ... or if the first argument is mandatory, so that it is not alone (at least two mandatory arguments) @decorator def replace_with ( g , a , f = DECORATED ): # ... If you can not afford a signature change, there are two other ways to work around this problem: change the default detector for first argument disambiguation. By default if a single argument is received, it will be assumed to be the true first arg (and not the decorator's target), if it is not a callable nor a class. If you are sure that a function of a certain type, or a class with certain caracteristics, can only be the argument and not the decorated object, then you can override this default logic. For example we could use @decorator(first_arg_disambiguator=lambda g: g in {foo}) in the above code.","title":"c- Advanced topics"}]}